import fs from 'fs';
import path from 'path';
import { stripWikiPrefix, removeIndexSuffix, slugify, ensureLeadingSlash } from './markdown-utils.js';

interface SyncedFile {
  path: string;
  fullPath: string;
}

interface FileManifest {
  files: SyncedFile[];
  generatedAt: string;
}

let cachedManifest: FileManifest | null = null;

/**
 * Load the synced files manifest generated by github-wiki-sync (synchronous)
 */
export function loadManifestSync(): FileManifest | null {
  if (cachedManifest) {
    return cachedManifest;
  }

  try {
    const manifestPath = path.join(process.cwd(), 'src/content/docs/.synced-files.json');
    const content = fs.readFileSync(manifestPath, 'utf-8');
    cachedManifest = JSON.parse(content);
    return cachedManifest;
  } catch (error) {
    // Manifest doesn't exist yet (first build or dev mode)
    return null;
  }
}

/**
 * Find a document file from a wikilink target
 * Similar to astro-loader-obsidian's getDocumentFromLink()
 *
 * @param target - The wikilink target (e.g., "page-name", "wiki/page-name", "folder/page")
 * @param files - Array of synced file paths
 * @returns The matched file path or null
 */
export function findDocumentFromLink(target: string, files: string[]): string | null {
  if (!target) return null;

  // Normalize the target
  let normalizedTarget = target;

  // Remove .md extension if present
  if (normalizedTarget.endsWith('.md')) {
    normalizedTarget = normalizedTarget.substring(0, normalizedTarget.length - 3);
  }

  // Remove /index suffix if present
  if (normalizedTarget.endsWith('/index')) {
    normalizedTarget = normalizedTarget.substring(0, normalizedTarget.length - 6);
  }

  // Try exact matches first
  for (const file of files) {
    const fileWithoutExt = file.endsWith('.md') ? file.substring(0, file.length - 3) : file;

    // Exact match
    if (file === target || fileWithoutExt === normalizedTarget) {
      return file;
    }

    // Match with .md added
    if (file === `${normalizedTarget}.md`) {
      return file;
    }

    // Match filename only (shortest path)
    const filename = fileWithoutExt.split('/').pop();
    const targetFilename = normalizedTarget.split('/').pop();
    if (filename === targetFilename) {
      return file;
    }
  }

  // Try fuzzy matching - ends with the target
  for (const file of files) {
    const fileWithoutExt = file.endsWith('.md') ? file.substring(0, file.length - 3) : file;
    if (fileWithoutExt.endsWith(`/${normalizedTarget}`) || fileWithoutExt.endsWith(`/${normalizedTarget}/index`)) {
      return file;
    }
  }

  return null;
}

/**
 * Resolve a wikilink to a URL using file-based resolution
 *
 * @param filePath - The wikilink target from urlResolver ({ filePath, isEmbed, heading })
 * @param heading - Optional heading anchor
 * @returns Resolved URL or fallback slug-based URL
 */
export function resolveWikilink(filePath: string, heading?: string): string {
  // Load manifest (synchronous)
  const manifest = loadManifestSync();

  let resolvedPath: string;

  if (manifest && manifest.files.length > 0) {
    // File-based resolution (preferred)
    const filePaths = manifest.files.map((f) => f.path);

    // Strip wiki/ prefix first
    const cleanPath = stripWikiPrefix(filePath);

    // Try to find the actual file
    const matchedFile = findDocumentFromLink(cleanPath, filePaths);

    if (matchedFile) {
      // Convert file path to URL slug
      let urlPath = matchedFile;

      // Remove .md extension
      if (urlPath.endsWith('.md')) {
        urlPath = urlPath.substring(0, urlPath.length - 3);
      }

      // Remove /index suffix
      if (urlPath.endsWith('/index')) {
        urlPath = urlPath.substring(0, urlPath.length - 6);
      }

      // Convert to slug
      urlPath = slugify(urlPath);
      resolvedPath = ensureLeadingSlash(urlPath);
    } else {
      // File not found - fallback to slug-based resolution
      console.warn(`[wikilink-resolver] File not found for link: ${filePath}`);
      let linkName = stripWikiPrefix(filePath);
      linkName = removeIndexSuffix(linkName);
      const slug = slugify(linkName);
      resolvedPath = ensureLeadingSlash(slug);
    }
  } else {
    // No manifest available - fallback to slug-based resolution
    // This happens during dev mode or first build
    let linkName = stripWikiPrefix(filePath);
    linkName = removeIndexSuffix(linkName);
    const slug = slugify(linkName);
    resolvedPath = ensureLeadingSlash(slug);
  }

  // Append heading anchor if present
  return heading ? `${resolvedPath}#${heading}` : resolvedPath;
}
